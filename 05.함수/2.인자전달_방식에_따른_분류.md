## 인자 전달 방식에 따른 분류

함수는 인자`argument` 전달 방식에 따라 크게 2개로 나누어짐

- 값에 의한 전달 `call by value`
- 참조에 의한 전달 `call by reference`
    
    ✔**단, 파이썬은 값에 의한 전달과 참조에 의한 전달 방식을 이용하지 않음**
    
    - 따라서 `C++` 코드로 이를 알아보자

### 2.1 값에 의한 전달 `call by value`

```cpp
#include <iostream>
using namespace std;

void change_value(int x, int value)//     #인자 x와 value를 받아 
{
	x = value; //                           #x에, value를 대입
	cout << "x : " << x << " in change_value" << endl;
}

int main(void)
{
	int x = 10;//                           #x에 10을 대입 후
	change_value(x, 20);//                  #change_value()함수를 호출
	cout << "x : " << x << " in main" << endl;

	return 0;
}

// 실행결과
x : 20 in change_value
x : 10 in main
```

- `main`함수 2번째 줄에서 `change_value()`인자 값에 20을 전달했으나 바뀌지 않음
    - 함수안에선 값이 바뀌었으나, `main`함수에서는 호출한 경우는 변경되지 않음
- 지역 변수 `x`가 변경되지 않은 이유는, 함수에 `x`가 전달될 때 값에 의한 전달 방식으로 전달 되었기 때문
- 함수가 호출 될 때 메모리에는 스택 프레임이 생기는데, 스택 프레임은 함수의 메모리 공간 즉, 지역변수가 존재하는 영역

---

잠시 함수가 호출 될 때 스택프레임의 모습을 살펴보자

```cpp
#include <iostream>
using namespace std;

int test(int a, int b);

int main(void)
{
	int a = 10, b = 5;//    #4
	int res = test(a, b);// #5
	cout << "result of test : " << res << endl;
	return 0;
}

int test(int a, int b)//  #1
{
	int c = a + b;//        #2
	int d = a - b;//        #3
	return c + d;
}
```

- `main` 함수에서 `test` 함수를 호출하는 부분을 잘 살펴보자
    - `test` 함수는 인자로 a와 b를 받고 (#1)
    - 지역 변수로 c와 d를 선언(#2,#3)
    - 함수를 호출하면 (#5) 아래와 같은 스택 프레임이 메모리에 생성

| test 함수 스택프레임 call by value |
| --- |
| d |
| c |
| a |
| b |

---

- `main` 함수 호출 시 스택프레임

| main 함수의 test() 스택프레임 |
| --- |
| d |
| c |
| a  |
| b |

| main 함수 스택프레임 |
| --- |
| res = test(a,b) |
| b = 5 |
| a = 10 |
- `main` 함수가 먼저 실행 되므로 스택 프레임이 먼저 쌓인다
- 이 후 `main` 함수 안에서 호출한 `test` 함수의 스택프레임은 그 위에 쌓인다
- `test` 함수가 모두 실행되면 `test` 함수의 스택 프레임이 먼저 사라진다
- 이 후에 프로그램이 종료 되면 `main` 함수의 스택 프레임이 사라진다

> 위 `main` 함수의 스택 프레임 공간에도 a와 b가 있고,
`test` 함수의 스택 프레임 공간에도 a와 b가 존재한다.

이 공간은 서로 독립된 공간으로 코드(#5)에서 인자를 전달 할 때 
`main` 함수 스택 프레임의 지역 변수인 a와 b를 전달 한 것 같지만,
실제로는 `test` 함수 스택 프레임의 지역 변수 a와 b에 값만 **‘복사`** 한 것
이 경우를 ’**값에 의한 전달 `call by value`'** 라고 한다.
> 

1. 그럼 다시 가장 **처음 코드의 실행 되기 직전에** 스택 프레임을 살펴보자

| change_value 함수의 스택프레임 |
| --- |
| x = 10 |
| value = 20 |

| main 함수의 스택프레임 |
| --- |
| x = 10 |
- `change_value` 함수 스택 프레임의 x와 `main` 함수 스택 프레임의 x는 서로 다른 메모리 공간에 존재하는 다른 변수이며, 값만 10으로 같다.

1. **코드가 실행 후**의 스택 프레임 모습

| change_value 함수의 스택프레임 |
| --- |
| x = 20 |
| value = 20 |

| main 함수의 스택프레임 |
| --- |
| x = 10 |
- x에 value 값을 대입했으니 x값은 20이다. 주목할 점은 두개의 함수가 서로 다른 변수이므로 x값은 변하지 않는다

1. **코드가 종류 후**의 스택 프레임 모습

| main 함수의 스택프레임 |
| --- |
| x = 10 |
- 이 상태에서 x값을 출력하면 당연히 10이 출력 된다.

## 추가 설명

**값에 의한 인수 전달**

```cpp
void func(int x) 
{
    x = 20;
}
int main()
{
    int a = 0;
    func(a); 
    cout << a << endl; // 0 출력
}
```

`func(a)` 함수 호출시 내부적으로 `int x = a` 가 실행된다.

- 함수의 지역변수이자 매개변수인 int x 에 a의 값이
    
    복사된다.
    
    - 따라서 func(a) 함수 호출이 끝난 후 이다. x는 단순히 a의 값을 **복사** 하여 가져간 것일 뿐이므로. a의 값은 변함 없이 0
- 인수의 값이 복사되어 매개변수에게 넘겨지는 것을 값에 의한 인수 전달 (call by value) 라고 한다.