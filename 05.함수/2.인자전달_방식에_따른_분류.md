## 인자 전달 방식에 따른 분류

함수는 인자`argument` 전달 방식에 따라 크게 2개로 나누어짐

- 값에 의한 전달 `call by value`
- 참조에 의한 전달 `call by reference`
    
    ✔**단, 파이썬은 값에 의한 전달과 참조에 의한 전달 방식을 이용하지 않음**
    
    - 따라서 `C++` 코드로 이를 알아보자

### 2.1 값에 의한 전달 `call by value`

```cpp
#include <iostream>
using namespace std;

void change_value(int x, int value)//     #인자 x와 value를 받아 
{
	x = value; //                           #x에, value를 대입
	cout << "x : " << x << " in change_value" << endl;
}

int main(void)
{
	int x = 10;//                           #x에 10을 대입 후
	change_value(x, 20);//                  #change_value()함수를 호출
	cout << "x : " << x << " in main" << endl;

	return 0;
}

// 실행결과
x : 20 in change_value
x : 10 in main
```

- `main`함수 2번째 줄에서 `change_value()`인자 값에 20을 전달했으나 바뀌지 않음
    - 함수안에선 값이 바뀌었으나, `main`함수에서는 호출한 경우는 변경되지 않음
- 지역 변수 `x`가 변경되지 않은 이유는, 함수에 `x`가 전달될 때 값에 의한 전달 방식으로 전달 되었기 때문
- 함수가 호출 될 때 메모리에는 스택 프레임이 생기는데, 스택 프레임은 함수의 메모리 공간 즉, 지역변수가 존재하는 영역

---

잠시 함수가 호출 될 때 스택프레임의 모습을 살펴보자

```cpp
#include <iostream>
using namespace std;

int test(int a, int b);

int main(void)
{
	int a = 10, b = 5;//    #4
	int res = test(a, b);// #5
	cout << "result of test : " << res << endl;
	return 0;
}

int test(int a, int b)//  #1
{
	int c = a + b;//        #2
	int d = a - b;//        #3
	return c + d;
}
```

- `main` 함수에서 `test` 함수를 호출하는 부분을 잘 살펴보자
    - `test` 함수는 인자로 a와 b를 받고 (#1)
    - 지역 변수로 c와 d를 선언(#2,#3)
    - 함수를 호출하면 (#5) 아래와 같은 스택 프레임이 메모리에 생성

| test 함수 스택프레임 call by value |
| --- |
| d |
| c |
| a |
| b |

---

- `main` 함수 호출 시 스택프레임

| main 함수의 test() 스택프레임 |
| --- |
| d |
| c |
| a  |
| b |

| main 함수 스택프레임 |
| --- |
| res = test(a,b) |
| b = 5 |
| a = 10 |
- `main` 함수가 먼저 실행 되므로 스택 프레임이 먼저 쌓인다
- 이 후 `main` 함수 안에서 호출한 `test` 함수의 스택프레임은 그 위에 쌓인다
- `test` 함수가 모두 실행되면 `test` 함수의 스택 프레임이 먼저 사라진다
- 이 후에 프로그램이 종료 되면 `main` 함수의 스택 프레임이 사라진다

> 위 `main` 함수의 스택 프레임 공간에도 a와 b가 있고,
`test` 함수의 스택 프레임 공간에도 a와 b가 존재한다.

> 이 공간은 서로 독립된 공간으로 코드(#5)에서 인자를 전달 할 때 
`main` 함수 스택 프레임의 지역 변수인 a와 b를 전달 한 것 같지만,
실제로는 `test` 함수 스택 프레임의 지역 변수 a와 b에 값만 **‘복사`** 한 것
이 경우를 ’**값에 의한 전달 `call by value`'** 라고 한다.
>

1. 그럼 다시 가장 **처음 코드의 실행 되기 직전에** 스택 프레임을 살펴보자

| change_value 함수의 스택프레임 |
| --- |
| x = 10 |
| value = 20 |

| main 함수의 스택프레임 |
| --- |
| x = 10 |
- `change_value` 함수 스택 프레임의 x와 `main` 함수 스택 프레임의 x는 서로 다른 메모리 공간에 존재하는 다른 변수이며, 값만 10으로 같다.

1. **코드가 실행 후**의 스택 프레임 모습

| change_value 함수의 스택프레임 |
| --- |
| x = 20 |
| value = 20 |

| main 함수의 스택프레임 |
| --- |
| x = 10 |
- x에 value 값을 대입했으니 x값은 20이다. 주목할 점은 두개의 함수가 서로 다른 변수이므로 x값은 변하지 않는다

1. **코드가 종류 후**의 스택 프레임 모습

| main 함수의 스택프레임 |
| --- |
| x = 10 |
- 이 상태에서 x값을 출력하면 당연히 10이 출력 된다.

## 추가 설명

**값에 의한 인수 전달**

```cpp
void func(int x) 
{
    x = 20;
}
int main()
{
    int a = 0;
    func(a); 
    cout << a << endl; // 0 출력
}
```

`func(a)` 함수 호출시 내부적으로 `int x = a` 가 실행된다.

- 함수의 지역변수이자 매개변수인 int x 에 a의 값이 복사된다.
    - 따라서 func(a) 함수 호출이 끝난 후 이다. x는 단순히 a의 값을 **복사** 하여 가져간 것일 뿐이므로. a의 값은 변함 없이 0
- 인수의 값이 복사되어 매개변수에게 넘겨지는 것을 값에 의한 인수 전달 (call by value) 라고 한다.


### 2.2 참조에 의한 전달 `call by reference`

말 그대로 값이 아닌 **참조**를 전달

```cpp
#include <iostream>
using namespace std;

void change_value(int * x, int value)//#1
{
	*x = value;                        //#2
	cout << "x : " << *x << " in change_value" << endl;
}

int main(void)
{
	int x = 10;                        //#3
	change_value(&x, 20);              //#4
	cout << "x : " << x << " in main" << endl;

	return 0;
}

#실행결과
x : 20 in change_value
x : 20 in main
```

✅ `*`은 포인터를 의미하며, `main` 함수의 x변수의 메모리 주소(위치)를  가르킴

✅ `&`은 주소의 인자를 전달하며, `main` 함수의 x변수의 메모리 주소를 전달

**🔽포인터에 대한 강의자료**

[모두를 위한 컴퓨터 과학 (CS50 2019)](https://www.boostcourse.org/cs112/lecture/119028?isDesc=false)

- `*x=value` 가 실행되기 직전에 스택 프레임 모습
    
    
    | change_value 함수 스택프레임 call by ref. |
    | --- |
    | x = 0x1111 1111 |
    | value = 20 |
    
    | main 함수 |
    | --- |
    | x = 10  >>> address : 0x1111 1111 |
- 위 스택 프레임을 살펴 봤을 때, #4에서 `&x` 는 값 10을 전달하는게 아닌 10을 저장하고 있는 4바이트 공간 중 첫번 째 바이트의 주소값을 전달한다.
- 포인터 변수`*` 가 주소 값을 저장한다는 것은 `change_value` 스택 프레임 안에 있는 `int` 형 포인터 x가 화살표를 따라 `main()` 함수의 지역 변수 x를 가르키는 것과 같은 의미
- 가르킨다는 말을 다른 말로 풀면 참조 `reference` 이므로, 인자로 변수의 참조를 전달 하는 방식은 참조에 의한 전달 `call by reference` 라고 한다.

---

- `*x=value` 가 실행된 후 스택 프레임 모습

| change_value 함수 스택프레임 call by ref. |
| --- |
| x = 0x1111 1111 |
| value = 20 |

| main 함수 |
| --- |
| x = 20  >>> address: 0x1111 1111 |
- #2에서 `*x` 를 역참조라고 하며, x에 저장 된 주소 값으로 접근한다.
- 접근 후 `value` 값을 대입 하면 `main` 함수의 지역 변수 x가 있는 메모리 공간에 `value` 값을 대입한다.
    - 최종으로 `x=20` 값이 출력된다.

---

### 2.3 객체참조에 의한 전달(파이썬) `call by object reference`

- 파이썬은 객체 참조에 의한 전달이라는 특별한 방식으로 인자를 전달한다.
    - 이번 절에서는 변경 불가능한 객체인 상수 객체를 인자로 전달해보자.

```python
def change_value(x, value):#3
    x = value              #4
    print("x : {} in change_value".format(x))

if __name__ == "__main__":
    x = 10                 #1
    change_value(x, 20)    #2
    print("x : {} in main".format(x))

#실행결과
x : 20 in change_value
x : 10 in main
```

- 주목할 점은 파이썬 변수는 C언어 처럼 변수라는 메모리 공간에 값을 직접 저장하지 않는다.
    - 변수 이름은 `값 객체` 즉, x는 10을 가르킨다.
    - 상수 객체는 변경 불가능한 객체이며, 변수 값을 바꾼다는 의미는 변수 이름이 가리키는 메모리 공간의 값을 직접 바꾸는게 아니라 바꾸고자 하는 상수 객체를 참조하는 것
    - 즉, #4는 x가 value가 가리키는 상수 객체(20)을 참조하게 만드는 코드이다.
- `change_value` 스택 프레임이 사라지며, 지역변수 x와 value가 사라지고, 레퍼런스 카운트[^1]가 0이 된 상수 객체 20도 사라진다. 그 후 x를 출력하면  10이 나온다.
    - 이 전 절에서 알아본 값에 의한 전달이나, 참조에 의한 전달 방식과는 다르다.

## 레퍼런스 카운트?

[^1]: 메모리 영역 중에 힙(heap)이라는 공간이 있다. Java, C#, 파이썬 등에서는 메모리를 프로그래머가 직접 관리하지 않고 해당 언어가 스스로 해제 합니다. 더는 사용하지 않는 메모리를 언어 차원에서 해제 한다는 개념을 가비지 컬렉선이라고 한다. (C/C++에서는 힙에 할당한 메모리는 프로그래머가 직접 해제)파이썬은 레퍼런스 카운팅으로 가비지 컬렉션을 구현한다. 레퍼런스는 참조 즉, 무언가를 가르킨다는 의미로서 변수는 값을 직접 갖는 게 아니라 상수 객체를 가리키고 있다고 했는데, 이러한 개념을 말한다. 
에를 들어 변수a와 10이라는 상수 객체를 가르킨다고 가정해보자. 가리키는 대상의 개수인 레퍼런스 카운트는 1이다. 이때 b=a 라는 코드를 입력하면 b도 10이라는 상수 객체를 가르키게 되며 상수 객체 10의 레퍼런스 카운트는 2가 된다.
만약, a와 b가 10이 아닌 서로 다른 객체를 가르키도록 수정하면, 상수 객체 10은 레퍼런스 카운트가 0이 되고 메모리에서 해제가 된다. 더 이상 10을 가르키는 객체가 없어 졌기 때문.